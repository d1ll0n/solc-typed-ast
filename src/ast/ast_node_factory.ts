import { ASTNode, ASTNodeConstructor } from "./ast_node";
import { ASTContext, ASTPostprocessor } from "./ast_reader";
import { argExtractionMapping } from "./ast_node_extractors";
import {
    ASTNodeClassEntries,
    ASTNodeConstructorMap,
    ASTNodeConstructorType,
    ASTNodeKind,
    ExtractedArguments,
    ContractDefinition,
    EnumDefinition,
    ErrorDefinition,
    EventDefinition,
    FunctionDefinition,
    StructDefinition,
    UserDefinedValueTypeDefinition,
    VariableDeclaration,
    Identifier,
    MemberAccess,
    IdentifierPath,
    ImportDirective,
    SourceUnit,
    VariableDeclarationStatement,
    UserDefinedTypeName,
    PrimaryExpression,
    YulIdentifier,
    YulFunctionDefinition,
    YulExpression,
    YulVariableDeclaration,
    YulFunctionCall,
    Literal,
    ElementaryTypeName,
    Expression,
    FunctionCall
} from "./implementation";
import {
    DataLocation,
    FunctionCallKind,
    FunctionStateMutability,
    FunctionVisibility,
    LiteralKind,
    Mutability,
    StateVariableVisibility
} from "./constants";
import { utf8ToHex } from "../misc/hex";

/**
 * When applied to following tuple type:
 * ```
 * [id: number, src: string, type: string, rest: any]
 * ```
 * Skips first three arguments (`id`, `src` and `type`) and infers only `rest`.
 *
 * This will further be applied to constructor argument tuple types, like
 * `ConstructorParameters<typeof VariableDeclaration>` (for example)
 * to infer only `VariableDeclaration`-specific arguments as the necessary.
 * The leading `id`, `src` and `type` will be generated by `ASTNodeFactory`.
 */
type Specific<Args extends any[]> = Args["length"] extends 0
    ? undefined
    : ((...args: Args) => void) extends (id: number, src: string, ...rest: infer Rest) => void
    ? Rest
    : [];

type IDMap = Map<number, number>;

type InternalMake = <C extends ASTNodeConstructorType>(
    ctor: C,
    ...args: ExtractedArguments<C>
) => InstanceType<C>;

type MakeNodeFunction<C extends ASTNodeConstructorType> = (
    ...args: ExtractedArguments<C>
) => InstanceType<C>;

type StaticMakeNodeFunction<C extends ASTNodeConstructorType> = (
    context: ASTContext,
    ...args: ExtractedArguments<C>
) => InstanceType<C>;

const getMakeFn = <C extends ASTNodeConstructorType>(ctor: C) =>
    function (this: { make: InternalMake }, ...args: ExtractedArguments<C>) {
        return this.make(ctor, ...args);
    };

const getStaticMakeFn = <T extends ASTNode>(ctor: ASTNodeConstructor<T>) =>
    function (context: ASTContext, ...args: Specific<ConstructorParameters<typeof ctor>>) {
        const node = new ctor(context.lastId + 1, "0:0:0", ...args);
        context.register(node);
        return node;
    };

type NodeFactory = {
    [K in ASTNodeKind as `make${K}`]: MakeNodeFunction<ASTNodeConstructorMap[K]>;
};

type BaseStaticNodeFactory = {
    [K in ASTNodeKind as `make${K}`]: StaticMakeNodeFunction<ASTNodeConstructorMap[K]>;
};

type IdentifiableNode =
    | VariableDeclaration
    | ContractDefinition
    | FunctionDefinition
    | StructDefinition
    | ErrorDefinition
    | EventDefinition
    | EnumDefinition
    | UserDefinedValueTypeDefinition
    | ImportDirective;

type IdentifiableYulNode =
    | FunctionDefinition
    | VariableDeclaration
    | Identifier
    | YulFunctionDefinition
    | YulVariableDeclaration;

interface StaticNodeFactory extends BaseStaticNodeFactory {
    makeIdentifierFor(target: IdentifiableNode): Identifier;

    makeYulIdentifierFor(target: IdentifiableYulNode, name?: string): YulIdentifier;

    makeYulFunctionCallFor(fn: YulFunctionDefinition, parameters: YulExpression[]): YulFunctionCall;

    makeTypeNameUint256(ctx: ASTContext): ElementaryTypeName;

    makeLiteralUint256(ctx: ASTContext, n: string | number): Literal;

    makeConstantUint256(
        ctx: ASTContext,
        name: string,
        value: string | number,
        scope: number
    ): VariableDeclaration;

    makeFunctionCallFor(fn: FunctionDefinition, args: Expression[]): FunctionCall;
}

export const staticNodeFactory = ASTNodeClassEntries.reduce(
    (obj, [key, ctor]) => {
        Object.defineProperty(obj, `make${key}`, {
            configurable: true,
            writable: false,
            enumerable: true,
            value: getStaticMakeFn(ctor as any)
        });
        return obj;
    },
    {
        makeIdentifierFor,
        makeYulIdentifierFor,
        makeFunctionCallFor,
        makeYulFunctionCallFor,
        makeTypeNameUint256,
        makeLiteralUint256,
        makeConstantUint256
    } as StaticNodeFactory
);

// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface ASTNodeFactory extends NodeFactory {}

export class ASTNodeFactory {
    context: ASTContext;
    postprocessor: ASTPostprocessor;

    get nextId(): number {
        // @todo this is inefficient - probably best to remove factory's lastId
        // and add similar tracking to ASTContext
        return this.context.lastId + 1;
    }

    constructor(context = new ASTContext(), postprocessor = new ASTPostprocessor()) {
        this.context = context;
        this.postprocessor = postprocessor;

        for (const [key, ctor] of ASTNodeClassEntries) {
            Object.defineProperty(this, `make${key}`, {
                configurable: true,
                writable: false,
                enumerable: true,
                value: getMakeFn(ctor)
            });
        }
    }

    makeFunctionCallFor(fn: FunctionDefinition, args: Expression[]): FunctionCall {
        return makeFunctionCallFor(fn, args);
    }

    makeVariableDeclarationStatementFromFunctionCall(
        functionCall: FunctionCall
    ): VariableDeclarationStatement {
        const variableDeclarations = (
            functionCall.vReferencedDeclaration as FunctionDefinition
        )?.vReturnParameters.vParameters.map((p) => this.copy(p));
        return this.makeVariableDeclarationStatement(
            variableDeclarations.map((v) => v.id),
            variableDeclarations,
            functionCall
        );
    }

    makeTypeNameUint256(): ElementaryTypeName {
        return makeTypeNameUint256(this.context);
    }

    makeLiteralUint256(value: string | number): Literal {
        return makeLiteralUint256(this.context, value);
    }

    makeConstantUint256(name: string, value: string | number, scope: number): VariableDeclaration {
        return makeConstantUint256(this.context, name, value, scope);
    }

    makePrimaryExpression(
        ...args: Specific<ConstructorParameters<typeof PrimaryExpression>>
    ): PrimaryExpression {
        return this.make(PrimaryExpression, ...args);
    }

    makeIdentifierFor(target: IdentifiableNode): Identifier {
        return makeIdentifierFor(target);
    }

    makeYulIdentifierFor(target: IdentifiableYulNode, name?: string): YulIdentifier {
        return makeYulIdentifierFor(target, name);
    }

    makeYulFunctionCallFor(
        fn: YulFunctionDefinition,
        parameters: YulExpression[]
    ): YulFunctionCall {
        return this.makeYulFunctionCall(this.makeYulIdentifierFor(fn), parameters);
    }

    makeUnfinalized<T extends ASTNode>(
        type: ASTNodeConstructor<T>,
        ...args: Specific<ConstructorParameters<typeof type>>
    ): T {
        const node = new type(this.nextId, "0:0:0", ...args);

        this.context.register(node);

        return node;
    }

    make<T extends ASTNode>(
        type: ASTNodeConstructor<T>,
        ...args: Specific<ConstructorParameters<typeof type>>
    ): T {
        const node = this.makeUnfinalized(type, ...args);

        this.postprocessor.processNode(node, this.context);

        return node;
    }

    copy<T extends ASTNode>(node: T): T {
        const cache = new Map<number, number>();
        const clone = this.copyHelper(node, cache);
        const context = this.context;
        const postprocessor = this.postprocessor;

        for (const child of clone.getChildren(true)) {
            this.patchIds(child, cache);

            postprocessor.processNode(child, context);
        }

        return clone;
    }

    private patchIds(node: ASTNode, cache: IDMap): void {
        const patch = (oldId: number): number => {
            const newId = cache.get(oldId);

            return newId === undefined ? oldId : newId;
        };

        if (
            node instanceof ContractDefinition ||
            node instanceof FunctionDefinition ||
            node instanceof StructDefinition ||
            node instanceof VariableDeclaration ||
            node instanceof ImportDirective
        ) {
            node.scope = patch(node.scope);
        }

        if (node instanceof ContractDefinition) {
            node.linearizedBaseContracts = node.linearizedBaseContracts.map(patch);
            node.usedErrors = node.usedErrors.map(patch);
        }

        if (
            node instanceof Identifier ||
            node instanceof IdentifierPath ||
            node instanceof MemberAccess ||
            node instanceof UserDefinedTypeName ||
            node instanceof YulIdentifier
        ) {
            node.referencedDeclaration = patch(node.referencedDeclaration);
        }

        if (node instanceof ImportDirective) {
            node.sourceUnit = patch(node.sourceUnit);
        }

        if (node instanceof SourceUnit) {
            const m = new Map<string, number>();

            for (const [k, v] of node.exportedSymbols) {
                m.set(k, patch(v));
            }

            node.exportedSymbols = m;
        }

        if (node instanceof VariableDeclarationStatement) {
            node.assignments = node.assignments.map((id) => (id === null ? id : patch(id)));
        }
    }

    private copyHelper<T extends ASTNode>(node: T, cache: IDMap): T {
        const ctor = node.constructor as ASTNodeConstructor<T>;
        const extractor = argExtractionMapping.get(ctor as ASTNodeConstructorType) as (
            node: T
        ) => Specific<ConstructorParameters<typeof ctor>>;

        if (extractor === undefined) {
            throw new Error(`Unable to find extractor for node constructor ${ctor.name}`);
        }

        const args = extractor(node).map((arg) => this.copyValue(arg, cache));
        const clone = this.makeUnfinalized(ctor, ...args);

        cache.set(node.id, clone.id);

        return clone;
    }

    private copyValue(value: any, cache: IDMap): any {
        if (value === null || value === undefined) {
            return value;
        }

        if (["string", "number", "bigint", "boolean"].includes(typeof value)) {
            return value;
        }

        if (value instanceof ASTContext) {
            return value;
        }

        if (value instanceof ASTNode) {
            return this.copyHelper(value, cache);
        }

        if (value instanceof Array) {
            return value.map((v) =>
                v instanceof ASTNode ? this.copyHelper(v, cache) : this.copyValue(v, cache)
            );
        }

        if (value instanceof Map) {
            const m = new Map();

            for (const [k, v] of value) {
                m.set(
                    k instanceof ASTNode ? this.copyHelper(k, cache) : this.copyValue(k, cache),
                    v instanceof ASTNode ? this.copyHelper(v, cache) : this.copyValue(v, cache)
                );
            }

            return m;
        }

        if (typeof value === "object") {
            const o: { [property: string]: any } = {};
            const hasProperty = Object.hasOwnProperty;

            for (const p in value) {
                if (hasProperty.call(value, p)) {
                    o[p] = this.copyValue(value[p], cache);
                }
            }

            return o;
        }

        throw new Error(`Cannot copy value ${JSON.stringify(value)} of type ${typeof value}`);
    }
}

const typeExtractor = (arg: VariableDeclaration): string => arg.typeString;

function makeIdentifierFor(target: IdentifiableNode): Identifier {
    let typeString: string;

    if (target instanceof VariableDeclaration) {
        typeString = target.typeString;
    } else if (target instanceof FunctionDefinition) {
        const args = target.vParameters.vParameters.map(typeExtractor);

        const result = [`function (${args.join(",")})`];

        if (target.stateMutability !== FunctionStateMutability.NonPayable) {
            result.push(target.stateMutability);
        }

        if (target.visibility !== FunctionVisibility.Public) {
            result.push(target.visibility);
        }

        if (target.vReturnParameters.vParameters.length) {
            const rets = target.vReturnParameters.vParameters.map(typeExtractor);

            result.push(`returns (${rets.join(",")})`);
        }

        typeString = result.join(" ");
    } else if (target instanceof ContractDefinition) {
        typeString = `type(contract ${target.name})`;
    } else if (target instanceof StructDefinition) {
        typeString = `type(struct ${target.canonicalName} storage pointer)`;
    } else if (target instanceof EnumDefinition) {
        typeString = `type(enum ${target.canonicalName})`;
    } else if (target instanceof UserDefinedValueTypeDefinition) {
        typeString = `type(${target.canonicalName})`;
    } else if (target instanceof EventDefinition || target instanceof ErrorDefinition) {
        const args = target.vParameters.vParameters.map(typeExtractor);

        typeString = `function (${args.join(",")})`;
    } else if (target instanceof ImportDirective) {
        typeString = "<missing>";

        if (target.unitAlias === "") {
            throw new Error('Target ImportDirective required to have valid "unitAlias"');
        }
    } else {
        throw new Error(
            "ASTNodeFactory.makeIdentifierFor(): Unable to compose typeString for supplied target"
        );
    }

    return staticNodeFactory.makeIdentifier(
        target.requiredContext,
        typeString,
        target instanceof ImportDirective ? target.unitAlias : target.name,
        target.id
    );
}

function makeYulIdentifierFor(target: IdentifiableYulNode, name?: string): YulIdentifier {
    if (target instanceof YulVariableDeclaration) {
        if (target.variables.length === 1) {
            name = target.variables[0].name;
        } else if (
            name === undefined ||
            target.variables.find((v) => v.name === name) === undefined
        ) {
            const declarationString = `${target.type} (${target.variables.map((v) => v.name)})`;
            throw Error(`variable ${name} not found in ${declarationString}`);
        }
    } else {
        name = target.name;
    }
    return staticNodeFactory.makeYulIdentifier(target.requiredContext, name, target.id);
}

function makeYulFunctionCallFor(
    fn: YulFunctionDefinition,
    parameters: YulExpression[]
): YulFunctionCall {
    return staticNodeFactory.makeYulFunctionCall(
        fn.requiredContext,
        staticNodeFactory.makeYulIdentifierFor(fn),
        parameters
    );
}

function makeTypeNameUint256(ctx: ASTContext): ElementaryTypeName {
    return staticNodeFactory.makeElementaryTypeName(ctx, "uint256", "uint256", "nonpayable");
}

function makeLiteralUint256(ctx: ASTContext, n: string | number): Literal {
    const value = n.toString();
    return staticNodeFactory.makeLiteral(
        ctx,
        `int_const ${value}`,
        LiteralKind.Number,
        utf8ToHex(value),
        value
    );
}

function makeConstantUint256(
    ctx: ASTContext,
    name: string,
    value: string | number,
    scope: number
): VariableDeclaration {
    return staticNodeFactory.makeVariableDeclaration(
        ctx,
        true,
        false,
        name,
        scope,
        false,
        DataLocation.Default,
        StateVariableVisibility.Internal,
        Mutability.Constant,
        "uint256",
        undefined,
        makeTypeNameUint256(ctx),
        undefined,
        makeLiteralUint256(ctx, value)
    );
}

function makeFunctionCallFor(fn: FunctionDefinition, args: Expression[]): FunctionCall {
    const {
        vParameters: { vParameters }
    } = fn;

    const paramTypeStrings = vParameters.map((v) => v.typeString);

    const functionTypeString = (
        paramTypeStrings.length > 1 ? `tuple(${paramTypeStrings.join(",")})` : paramTypeStrings[0]
    )
        .replace(/(struct\s+)([\w\d]+)/g, "$1$2 memory")
        .replace(/\[\]/g, "[] memory");

    const identifier = staticNodeFactory.makeIdentifierFor(fn);

    return staticNodeFactory.makeFunctionCall(
        fn.requiredContext,
        functionTypeString,
        FunctionCallKind.FunctionCall,
        identifier,
        args
    );
}
